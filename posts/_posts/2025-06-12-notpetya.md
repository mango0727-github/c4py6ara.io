---
layout: post
title: Petya? It's Notpetya
description: >
  Detailed analysis on malware, Notpetya which was named for its similarity to a famous malware, Petya.
sitemap: false
hide_last_modified: true
---
# Petya? It's Notpetya

## Overview

| Type | Contents |
| --- | --- |
| MD5 | 78c81c0421acf76e9b7e12a3517c8eb0 |
| 주요 동작 | 데이터 암호화, 탐지 회피, 복구 방지를 위한 볼륨셰도우 및 암호화키 삭제 |
| 드롭 파일 | 폴더별 Readme.txt |
| 뮤텍스명 | epoxzqjor |
| C&C 서버 | hxxp[://]134[.]249[.]116[.]78/<br>hxxp[://]errstock[.]tech/<br>hxxp[://]576v7e3a1o[.]viewsup[.]party/<br>hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ |

## Behavioral flow

![image.png](/assets/img/notpetya/image.png)

1. 피해자의 악성 웹사이트 방문(hxxp[://]daonasset[.]kr/)
2. Landing page 1: 악성 JS hxxp[://]134[.]249[.]116[.]78/jquery[.]js 로드
3. Landing page 2: hxxp[://]errstock[.]tech/로 리디렉션
4. Landing page 3: hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B
5. Landing page 4: hxxp[://]576v7e3a1o[.]viewsup[.]party/
6. Landing page 5: hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71
7. Landing page 5에 의하여 악성 DLL 다운로드(hxxp[://]576v7e3a1o[.]viewsup[.]party/a68db7f159e3ab5aded3d4a9feda3c26) 및 프로세스에 악성 DLL injection
8. DLL 실행 시 LoadLibrary 함수를 동적으로 호출하여dll, kernel32.dll 로드
9. DLL의 data section에 저장되어 있던 shellcode 디코딩
10. Shellcode 복사를 위한 가상 메모리 할당 후 실행, 읽기, 쓰기권한 부여
11. 최종 shellcode를 실행 권한이 있는 메모리 주소로 복사
12. Shellcode 실행
13. Shellcode는 mutex 생성
14. 암호화 알고리즘에 의하여 파일만 암호화 진행
15. 암호화 완료 후 폴더별 랜섬노트 드롭
16. 복구 방지를 위하여 암호화에 사용된 키 및 볼륨 셰도우 삭제

## Analysis details

최초 피해자가 hxxp[://]daonasset[.]kr/를 방문하였을 때의 사이트를 보면 난독화된 JS 코드가 삽입되어 있는 모습을 볼 수 있다.

![Figure 1. hxxp[://]daonasset[.]kr/ 내 암호화 코드](image%201.png)

Figure 1. hxxp[://]daonasset[.]kr/ 내 암호화 코드

이 난독화 코드를 파이썬을 활용하여 해독해보면 아래와 같이 hxxp[://]134[.]249[.]116[.]78/jquery[.]js를 로드하여 실행함을 알 수 있다.

![Figure 2. 암호화 코드 복호화 결과](image%202.png)

Figure 2. 암호화 코드 복호화 결과

hxxp[://]134[.]249[.]116[.]78/jquery[.]js도 마찬가지로 난독화되어 있는데, 이를 디코딩해보면 다음과 같다.

![Figure 3. Fiddler 내 인코딩된 hxxp[://]134[.]249[.]116[.]78/jquery[.]js](image%203.png)

Figure 3. Fiddler 내 인코딩된 hxxp[://]134[.]249[.]116[.]78/jquery[.]js

![Figure 4. 복호화된 hxxp[://]134[.]249[.]116[.]78/jquery[.]js](image%204.png)

Figure 4. 복호화된 hxxp[://]134[.]249[.]116[.]78/jquery[.]js

이후 hxxp[://]errstock[.]tech/로 리디렉션되며 이는 복호화하면 다음과 같으며, 이는 즉 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B로 리디렉션된다.

![Figure 5. 복호화된 hxxp[://]errstock[.]tech/ 내 코드로 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ + hwlkrs의 URL로 리디렉션](image%205.png)

Figure 5. 복호화된 hxxp[://]errstock[.]tech/ 내 코드로 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ + hwlkrs의 URL로 리디렉션

이어서 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B는 다음과 같은 코드에 의하여 hxxp[://]576v7e3a1o[.]viewsup[.]party/로 리디렉션 된다.

![Figure 6. 복호화된 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B 내 코드](image%206.png)

Figure 6. 복호화된 hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B 내 코드

hxxp[://]576v7e3a1o[.]viewsup[.]party/는 아래와 같이 VBSCode가 Base64로 난독화되어 있다.

![Figure 7. Fiddler 내 Base64로 난독화된 hxxp[://]576v7e3a1o[.]viewsup[.]party/ 내 VBScript](image%207.png)

Figure 7. Fiddler 내 Base64로 난독화된 hxxp[://]576v7e3a1o[.]viewsup[.]party/ 내 VBScript

이를 복호화해보면 hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71으로 리디렉션되는 것을 볼 수 있다.

![Figure 8. 복호화된 VBScript 중 일부 재 복호화 결과](image%208.png)

Figure 8. 복호화된 VBScript 중 일부 재 복호화 결과

hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71는 hxxp[://]576v7e3a1o[.]viewsup[.]party/a68db7f159e3ab5aded3d4a9feda3c26에 요청하여 미상의 파일(DLL로 추정)을 다운받아 rundll32 프로세스를 실행하여 다운받은 DLL의 n67urvvgfdgf export 함수를 호출한다. DLL 다운 시 %homepath&에 m58111U라는 디렉토리를 생성하기 때문에 파일은 이 위치에 드롭된다.

GetObject에 사용된 GUID는 Wbem locator로, 이를 통해 WMI에 연결하여 win32 Process를 실행하고 여기에 DLL을 injection하는 것으로 볼 수 있겠다.

![Figure 9. GetObject에 사용된 GUID 식별](image%209.png)

Figure 9. GetObject에 사용된 GUID 식별

![Figure 10. hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71 내 DLL 다운로드 및 injection 루틴](image%2010.png)

Figure 10. hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71 내 DLL 다운로드 및 injection 루틴

드롭된 DLL 파일은 과제에 의하여 제공된 것으로 보인다. 따라서 이를 PEStudio로 분석해보면 아래와 같으며, 예상한대로 DLL이며 64비트 환경에서 구동가능한 것을 알 수 있다. 또한 엔트로피가 높은 편이어서 그런지 유의미한 String은 찾아볼 수 없었다.

![Figure 11. DLL PEStudio 분석결과](image%2011.png)

Figure 11. DLL PEStudio 분석결과

PEiD와 PEbear로 분석해본 결과 packing에 대한 정보는 찾아볼 수 없었다. 특히, text section의 사이즈가 눈에 띄게 작지 않을 것을 봤을 때, 확실히 packing된 것 같지는 않다.

![Figure 12. PE-bear 분석결과](image%2012.png)

Figure 12. PE-bear 분석결과

다음으로 이를 실제로 실행시켰을 때 어떠한 기능을 하는지 알아보고자, Fiddler에서 식별한 함수 이름을 활용하여 동 악성코드를 실행시켜봤다.

![Figure 13. Fiddler에서 식별한 방식을 모방한 DLL 실행](image%2013.png)

Figure 13. Fiddler에서 식별한 방식을 모방한 DLL 실행

Process explorer 분석 결과 대략적으로 mutex 생성, 암호화 진행, 랜섬노트 전시 순으로 진행되는 것을 알 수 있었다. Mutex 이름은 epoxzqjor이다.

![Figure 14. Process Explorer 상 mutex 식별](image%2014.png)

Figure 14. Process Explorer 상 mutex 식별

Procmon의 process 트리를 보면 마지막 단계에서 wmic process call create “cmd /c computerdefaults.exe”를 실행하는 모습을 볼 수 있다. 이는 윈도우 설정 중 기본 프로그램을 설정하는 프로그램이다. 그러나, Regshot을 통해 키가 추가된 모습을 보면 알 수 있듯, 설정창이 실행되면 wmic process call create “vssadmin.exe Delete Shadows /all /quiet” 이 실행되는 것을 확인할 수 있다. vssadmin.exe는 윈도우의 볼륨 섀도우 복사본을 관리하는 프로그램으로 모든 볼륨 shadow를 피해자가 알아채지 못하게 모두 삭제하는 것을 고려 시, 암호화된 파일들을 영구적으로 복구하지 못하도록 만드는 것을 알 수 있다.

![Figure 15. Procmon의 Process tree 상 식별된 악성 DLL 관련 프로세스들](image%2015.png)

Figure 15. Procmon의 Process tree 상 식별된 악성 DLL 관련 프로세스들

![Figure 16. computerdefaults 명령어를 통한 윈도우 기본프로그램 실행](image%2016.png)

Figure 16. computerdefaults 명령어를 통한 윈도우 기본프로그램 실행

![Figure 17. computerdefaults 명령어로 실행된 기본프로그램 설정화면](image%2017.png)

Figure 17. computerdefaults 명령어로 실행된 기본프로그램 설정화면

![Figure 18. 윈도우 설정 프로그램 실행 시 실행되는 루틴으로, 악성 DLL에 의하여 key 및 value 추가](image%2018.png)

Figure 18. 윈도우 설정 프로그램 실행 시 실행되는 루틴으로, 악성 DLL에 의하여 key 및 value 추가

실행이 종료되면 다음과 같이 경고창이 뜨고, 파일 시스템 내 파일들이 모두 암호화된 것을 볼 수 있었으며, 특히 확장자 명이 전부 바뀌었다. 또한 친절하게도 가상화폐를 보낼 수 있는 웹사이트까지 실행시켜준다.

![Figure 19. 악성 파일 실행 후 랜섬노트 팝업. 이 text 파일은 모든 폴더에 존재](image%2019.png)

Figure 19. 악성 파일 실행 후 랜섬노트 팝업. 이 text 파일은 모든 폴더에 존재

![Figure 20. 암호화된 파일들은 확장자가 mutex 이름으로 변경](image%2020.png)

Figure 20. 암호화된 파일들은 확장자가 mutex 이름으로 변경

![Figure 21. 악성 DLL 실행 후 암호화폐 송금을 위한 웹페이지 팝업](image%2021.png)

Figure 21. 악성 DLL 실행 후 암호화폐 송금을 위한 웹페이지 팝업

Regshot으로 변화된 레지스트리를 비교해보자, 총 171개의 레지스트리가 삭제, 생성, 수정된 것을 볼 수 있었다.

![Figure 22. 악성 DLL에 의한 레지스트리 추가, 삭제, 수정 결과](image%2022.png)

Figure 22. 악성 DLL에 의한 레지스트리 추가, 삭제, 수정 결과

그 중 눈여겨볼 만한 것은 앞서 말한 바와 같이 ms-setting의 shell/open/command 키와 값이 추가된 것이었다.

![Figure 23. 악성 DLL에 의하여 추가된 레지스트리 키](image%2023.png)

Figure 23. 악성 DLL에 의하여 추가된 레지스트리 키

![Figure 24. 악성 DLL에 의하여 수정된 레지스트리(ms-setting 하위 키) 키의 value 수정](image%2024.png)

Figure 24. 악성 DLL에 의하여 수정된 레지스트리(ms-setting 하위 키) 키의 value 수정

![Figure 25. value 디코딩 결과, C:\Windows\system32\wbem\wmic process call create “vssadmin.exe Delete Shadows /all /quiet”](image%2025.png)

Figure 25. value 디코딩 결과, C:\Windows\system32\wbem\wmic process call create “vssadmin.exe Delete Shadows /all /quiet”

좀 더 세부적으로 살펴보고자 DLL을 Ghidra에 로드하니 Export 함수가 보이지 않았다. 이는 아마 의도적으로 분석노력을 방해하기 위해 일종의 조치를 취한 것으로 보인다. DLL entry에 진입 후 처음에 DLL의 작동과정을 순서대로 설명해보고자 한다.

가장 먼저 동적으로 LoadLibrary 함수를 직접 호출이 아닌 간접적으로 호출하여dll과 kernel32.dll을 로드한다.

![Figure 26. 간접호출을 통한 LoadLibrary 함수 호출](image%2026.png)

Figure 26. 간접호출을 통한 LoadLibrary 함수 호출

이후 GlobalAlloc 함수를 간접호출하여 이를 ptr_code에 저장함으로써 추후 코드 전반에 걸쳐 지속 활용한다.

![Figure 27. 간접호출을 통한 GlobalAlloc 함수 포인터 정의](image%2027.png)

Figure 27. 간접호출을 통한 GlobalAlloc 함수 포인터 정의

이어서 data section에 shellcode로 추정되는 코드를 복호화하는 루틴이 실행된다. 이는 XOR 연산으로 진행되는데, base address부터 차례대로 1개 바이트씩, 0x01~0xFF와 XOR 연산을 시행한다. 0xFF까지 연산이 되었다면 그 다음 바이트는 다시 0x01과 XOR 연산이 진행된다.

![Figure 28. DLL의 data section 내 shellcode 복호화 루틴](image%2028.png)

Figure 28. DLL의 data section 내 shellcode 복호화 루틴

다음으로는 Windows 버전과 빌드넘버에 따라서 shellcode를 수정하는 루틴이 진행되는데, data section에 해당하는 부분이 아닌 처음 prelude에 해당하는 부분이 사용자의 환경에 따라서 변경되는 것으로 보인다.

![Figure 29. Windows 환경에 따른 shellcode 파인튜닝 루틴 2](image%2029.png)

Figure 29. Windows 환경에 따른 shellcode 파인튜닝 루틴 2

![Figure 30. Windows 10 여부에 따라 다른 파인튜닝 루틴 시행](image%2030.png)

Figure 30. Windows 10 여부에 따라 다른 파인튜닝 루틴 시행

![Figure 31. Windows 10일 경우 빌드넘버에 따라 다른 파인튜닝 루틴 시행](image%2031.png)

Figure 31. Windows 10일 경우 빌드넘버에 따라 다른 파인튜닝 루틴 시행

> 참고로 Windows 버전과 빌드넘버는 _DAT_7ffe026c_ (윈도우 버전)과 _DAT_7ffe0260_ (빌드넘버)를 참조한다. 보고서에는 가독성을 위하여 각각 이름이 이해하기 쉬운 명칭으로 변경되었다. _DAT_7ffe0000은 KUSER_SHARED_DATA struct가 저장되어있는 위치로, 이 구조체의 구성은 다음과 같다.
> 

![Figure 32. KUSER_SHARED_DATA 구조체 구성 일부로 동 DLL은 0x0260과 0x026C 오프셋 활용](image%2032.png)

Figure 32. KUSER_SHARED_DATA 구조체 구성 일부로 동 DLL은 0x0260과 0x026C 오프셋 활용

이후 가상 메모리를 할당하고 해당 메모리구역에 실행, 읽기, 쓰기 권한을 부여한 다음 data section에 있던 shellcode를 할당한 메모리 구역으로 복사하는 루틴이 진행된다.

![Figure 33. shellcode 복사 루틴](image%2033.png)

Figure 33. shellcode 복사 루틴

복사가 완료된 이후 shellcode가 실행된다.

![Figure 34. 복사가 완료된 shellcode 실행](image%2034.png)

Figure 34. 복사가 완료된 shellcode 실행

![Figure 35. x64dbg 상 shellcode 실행 루틴](image%2035.png)

Figure 35. x64dbg 상 shellcode 실행 루틴

Shellcode는 먼저 탐지 회피를 위해 함수 간접호출 방식으로 dll, advapi32.dll, ntdll.dll, user32.dll 로드 및 볼륨정보, 시스템 정보(환경변수, 컴퓨터 이름 등) 수집 후 뮤택스를 생성한다. 뮤택스 이름은 앞서 확인대로 epoxzqjor이다.

![Figure 36. shellcode 상 뮤택스 생성 루틴](image%2036.png)

Figure 36. shellcode 상 뮤택스 생성 루틴

뮤택스 생성 후 파일경로 획득 및 사용자 폴더를 모두 순회하며, 암호화를 진행하고 각 폴더마다 랜섬노트를 드롭한다.

![Figure 37. 파일 암호화 및 폴더별 Readme.txt 드롭 루틴](image%2037.png)

Figure 37. 파일 암호화 및 폴더별 Readme.txt 드롭 루틴

이후 암호화에 사용된 key를 삭제하여 복원할 수 없게 만든다.

## Conclusion

이 Magnitude EK는 웹 브라우저 취약점, 특히 구 버전의 IE의 취약점을 이용하여 수개의 Landing page를 거쳐 DLL 악성코드 Magniber를 유포 및 실행한다.

특히, 현재 크롬이나 파이어폭스에서는 지원하지 않는 VBScript를 활용하여 DLL injection을 수행한다는 점을 고려 시 최신 브라우저를 사용하는 것의 중요성을 다시금 일깨워주고 있다.

악성 DLL Magniber는 각종 탐지 수단의 회피를 위하여 간접적으로 함수를 호출하고 data section에 있는 shellcode를 복사하는 방식을 채용하여 AV 회피를 효과적으로 수행하며, OS 버전과 빌드넘버에 따라 shellcode 일부를 수정하는 등 호환성 측면에서의 노력도 돋보였다.

최종적으로 동적분석 간 식별된 파일 암호화와 볼륨 쉐도우삭제까지 이르는 핵심적인 기능을 하는 shellcode의 분석을 좀 더 할 수 있었으면 좋았겠지만, 지식의 한계로 shellcode의 디컴파일 후 분석까지는 수행하지 못하였다.

다만, 분명한 것은 악성 DLL은 실행 후 자가삭제 기능이나 지속성 유지를 위한 기능은 식별되지 않으며, 시스템 운영이 필수적인 파일들은 그대로 두고 사용자가 활용할만한 파일 확장자들만 골라서 암호화하는 모습을 관찰할 수 있었다. 이는 아마도 shellcode 디컴파일을 수행하게 되면 원활하게 정확히 어떤 파일들을 어떤 알고리즘을 거쳐서 암호화하는지 확인할 수 있을 것이다.
