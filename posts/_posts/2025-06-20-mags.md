---
layout: post
title: Magnitude to Magniber
description: >
  Detailed analysis on an exploit kit, Magnitude, and its payload, Magniber.
sitemap: false
hide_last_modified: true
---
# Magnitude to Magniber

## Overview

| MD5 | 78c81c0421acf76e9b7e12a3517c8eb0 |
| --- | --- |
| Key behaviors | Delete volume shadow and encryption key to encrypt data, avoid detection, and prevent recovery |
| Drop files | Folder-specific Readme.txt |
| Mutex name | epoxzqjor |
| C&C Server | hxxp[://]134[.]249[.]116[.]78/<br>hxxp[://]errstock[.]tech/<br>hxxp[://]576v7e3a1o[.]viewsup[.]party/<br>hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ |


## Behavioral flow

![image.png](image.png)

1. Victim's visit to the malicious website (hxxp[://]daonasset[.]kr/)
2. Landing page 1: Loading malicious JS hxxp[://]134[.]249[.]116[.]78/jquery[.]js
3. Landing page 2: Redirect to hxxp[://]errstock[.]tech/
4. Landing page 3: hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B
5. Landing page 4: hxxp[://]576v7e3a1o[.]viewsup[.]party/
6. Landing page 5: hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71
7. Malicious DLL downloaded by Landing page 5 (hxxp[://]576v7e3a1o[.]viewsup[.]party/a68db7f159e3ab5aded3d4a9feda3c26) and malicious DLL injection into process
8. Dynamic call to LoadLibrary function at DLL execution to loaddll, kernel32.dll
9. Decoding shellcode that was stored in the data section of the DLL
10. Allocating virtual memory for copying shellcode and granting execute, read, and write permission
11. Copy the final shellcode to the memory address with execute permission
12. Execute the shellcode
13. Shellcode creates a mutex
14. Encrypt only files by encryption algorithm
15. Drop ransom note by folder after encryption completion
16. Delete the key and volume shadow used for encryption to prevent recovery

## Analysis details

When the first victim visited hxxp[://]daonasset[.]kr/, the site was embedded with obfuscated JS code.

![Figure 1. Encryption code inside hxxp[://]daonasset[.]kr/](image%201.png)

Figure 1. Encryption code inside hxxp[://]daonasset[.]kr/

If we decrypt this obfuscated code using Python, we can see that it loads and executes hxxp[://]134[.]249[.]116[.]78/jquery[.]js as shown below.

![Figure 2. Encryption code decryption result](image%202.png)

Figure 2. Encryption code decryption result

Similarly obfuscated is hxxp[://]134[.]249[.]116[.]78/jquery[.]js, which we can decode as follows.

![Figure 3. Encoded hxxp[://]134[.]249[.]116[.]78/jquery[.]js in Fiddler](image%203.png)

Figure 3. Encoded hxxp[://]134[.]249[.]116[.]78/jquery[.]js in Fiddler

![Figure 4. Decrypted hxxp[://]134[.]249[.]116[.]78/jquery[.]js](image%204.png)

Figure 4. Decrypted hxxp[://]134[.]249[.]116[.]78/jquery[.]js

It then redirects to hxxp[://]errstock[.]tech/, which, when decrypted, looks like this: hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B.

![Figure 5. Decrypted hxxp[://]errstock[.]tech/ redirected to URL of hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ + hwlkrs with my code](image%205.png)

Figure 5. Decrypted hxxp[://]errstock[.]tech/ redirected to URL of hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/ + hwlkrs with my code

Next, hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B is redirected to hxxp[://]576v7e3a1o[.]viewsup[.]party/ with the following code

![Figure 6. Decoded script in  hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B ](image%206.png)

Figure 6. Decoded script in  hxxp[://]2878d6fj42e1i09x[.]wentpi[.]com/0%7B95232%7B95520%7B106464%7B106368%7B88992%7B88896%7B0%7B1101360%7B2104320%7B26520%7B617760%7B26544%7B1176960%7B 

hxxp[://]576v7e3a1o[.]viewsup[.]party/ has the VBS code obfuscated to Base64 as shown below.

![Figure 7. Base64-obfuscated VBScript in hxxp[://]576v7e3a1o[.]viewsup[.]party/ in Fiddler](image%207.png)

Figure 7. Base64-obfuscated VBScript in hxxp[://]576v7e3a1o[.]viewsup[.]party/ in Fiddler

If you try to decrypt it, you can see that it redirects to hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71.

![Figure 8. Re-decryption result of some of the decrypted VBScripts](image%208.png)

Figure 8. Re-decryption result of some of the decrypted VBScripts

hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71ëŠ” hxxp[://]576v7e3a1o[.]viewsup[.]party/a68db7f159e3ab5aded3d4a9feda3c26 to download an unknown file (presumably a DLL) and execute the rundll32 process to call the n67urvvgfdgf export function of the downloaded DLL. The DLL creates a directory named m58111U in %homepath& when it is downloaded, so the file is dropped into this location.

The GUID used in GetObject is the Wbem locator, which we can see is used to connect to WMI to run a win32 Process and inject the DLL into it.

![Figure 9. Identifying the GUID used in GetObject](image%209.png)

Figure 9. Identifying the GUID used in GetObject

![Figure 10. DLL download and injection routine inside hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71](image%2010.png)

Figure 10. DLL download and injection routine inside hxxp[://]576v7e3a1o[.]viewsup[.]party/3b620f956dcae45951c1dc058f2b0b71

The dropped DLL file seems to have been provided by the assignment, so I analyzed it with PEStudio and found that it is a DLL as expected and can run in a 64-bit environment. Also, the entropy is high, so there are no significant strings.

![Figure 11. DLL PEStudio analysis result](image%2011.png)

Figure 11. DLL PEStudio analysis result

When analyzed with PEiD and PEbear, there is no information about packing. In particular, the size of the text section is not noticeably smaller, so it does not seem to be packed.

![Figure 12. PE-bear analysis results](image%2012.png)

Figure 12. PE-bear analysis results

Next, we wanted to see what it actually does when executed, so we ran the malware using the function names identified by Fiddler.

![Figure 13. DLL execution mimicking the behavior identified by Fiddler](image%2013.png)

Figure 13. DLL execution mimicking the behavior identified by Fiddler

The Process explorer analysis showed that the malware roughly creates a mutex, performs encryption, and displays the ransom note. The mutex is named epoxzqjor.

![Figure 14. Mutex identification in Process Explorer](image%2014.png)

Figure 14. Mutex identification in Process Explorer

If you look at the process tree in Procmon, you can see that the last step is to run the wmic process call create "cmd /c computerdefaults.exe". This is a program that sets the default programs during Windows setup. However, as you can see from the Regshot that the key was added, the wmic process call create "vssadmin.exe Delete Shadows /all /quiet" is executed when the Settings window is run. The vssadmin.exe is a program that manages volume shadow copies of Windows, and given that it deletes all volume shadows without the victim noticing, we can see that it makes the encrypted files permanently unrecoverable.

![Figure 15. Malicious DLL-related processes identified in Procmon's Process tree](image%2015.png)

Figure 15. Malicious DLL-related processes identified in Procmon's Process tree

![Figure 16. Running Windows Default Programs via the computerdefaults command](image%2016.png)

Figure 16. Running Windows Default Programs via the computerdefaults command

![Figure 17. Default program settings screen executed with the computerdefaults command](image%2017.png)

Figure 17. Default program settings screen executed with the computerdefaults command

![Figure 18. Routine executed when running the Windows Setup program, adding key and value by the malicious DLL](image%2018.png)

Figure 18. Routine executed when running the Windows Setup program, adding key and value by the malicious DLL

When the program finished executing, a warning window appeared as shown below, and I could see that all the files in the file system were encrypted, especially the extension names. It also kindly launches a website where you can send cryptocurrency.

![Figure 19. Ransom note popup after executing the malicious file. This text file is present in every folder](image%2019.png)

Figure 19. Ransom note popup after executing the malicious file. This text file is present in every folder

![Figure 20. Encrypted files are renamed with mutex extensions.](image%2020.png)

Figure 20. Encrypted files are renamed with mutex extensions.

![Figure 21. A webpage pops up after executing the malicious DLL to send cryptocurrency.](image%2021.png)

Figure 21. A webpage pops up after executing the malicious DLL to send cryptocurrency.

Comparing the registry changes with Regshot, we found that a total of 171 registries were deleted, created, and modified.

![Figure 22. Registry additions, deletions, and modifications by malicious DLLs](image%2022.png)

Figure 22. Registry additions, deletions, and modifications by malicious DLLs

Most notably, the shell/open/command key and value of ms-setting were added, as mentioned earlier.

![Figure 23. Registry keys added by malicious DLLs](image%2023.png)

Figure 23. Registry keys added by malicious DLLs

![Figure 24. Modified value of registry (ms-setting subkey) key modified by the malicious DLL](image%2024.png)

Figure 24. Modified value of registry (ms-setting subkey) key modified by the malicious DLL

![Figure 25. value decoding result, C:\Windows\system32\wbem\wmic process call create "vssadmin.exe Delete Shadows /all /quiet"](image%2025.png)

Figure 25. value decoding result, C:\Windows\system32\wbem\wmic process call create "vssadmin.exe Delete Shadows /all /quiet"

To dig a little deeper, I loaded the DLL into Ghidra and didn't see the Export function. This was probably done on purpose to thwart our analysis efforts. After entering the DLL entry, I would like to explain the operation of the DLL in order.

First, we dynamically call the LoadLibrary function indirectly instead of directly to load dll and kernel32.dll.

![Figure 26. Calling the LoadLibrary function via indirect call](image%2026.png)

Figure 26. Calling the LoadLibrary function via indirect call

We then indirectly call the GlobalAlloc function and store it in ptr_code, which we will continue to utilize throughout the rest of the code.

![Figure 27. Defining a pointer to the GlobalAlloc function via indirect call](image%2027.png)

Figure 27. Defining a pointer to the GlobalAlloc function via indirect call

Next, a routine is executed to decrypt the code in the data section that is assumed to be shellcode. This is done by performing an XOR operation with 0x01 through 0xFF, one byte at a time, starting at the base address. Once the operation has reached 0xFF, the next byte is XORed with 0x01 again.

![Figure 28. Shellcode decryption routine in the data section of the DLL](image%2028.png)

Figure 28. Shellcode decryption routine in the data section of the DLL

Next is a routine to modify the shellcode according to the Windows version and build number, and it seems that the part corresponding to the first prelude, not the data section, is changed according to the user's environment.

![Figure 29. Shellcode fine-tuning routine according to Windows environment 2](image%2029.png)

Figure 29. Shellcode fine-tuning routine according to Windows environment 2

![Figure 30. Different fine-tuning routines depending on whether you are on Windows 10 or not](image%2030.png)

Figure 30. Different fine-tuning routines depending on whether you are on Windows 10 or not

![Figure 31. Different fine-tuning routines based on build number for Windows 10](image%2031.png)

Figure 31. Different fine-tuning routines based on build number for Windows 10

> Note that the Windows version and build number refer to _DAT_7ffe026c_ (Windows version) and _DAT_7ffe0260_ (build number). These have been renamed for readability in the report. DAT_7ffe0000 is the location where the KUSER_SHARED_DATA struct is stored, which is organized as follows
> 

![Figure 32. As part of the KUSER_SHARED_DATA struct, the DLL utilizes offsets 0x0260 and 0x026C.](image%2032.png)

Figure 32. As part of the KUSER_SHARED_DATA struct, the DLL utilizes offsets 0x0260 and 0x026C.

The routine then allocates virtual memory, grants execute, read, and write access to that memory area, and then copies the shellcode from the data section to the allocated memory area.

![Figure 33. Shellcode Copy Routine](image%2033.png)

Figure 33. Shellcode Copy Routine

After the copying is complete, the shellcode is executed.

![Figure 34. Executing shellcode after copying is completed](image%2034.png)

Figure 34. Executing shellcode after copying is completed

![Figure 35. Shellcode execution routine on x64dbg](image%2035.png)

Figure 35. Shellcode execution routine on x64dbg

Shellcode first loads dll, advapi32.dll, ntdll.dll, user32.dll, and collects volume information, system information (environment variables, computer name, etc.), and creates a mutex after indirectly calling a function to avoid detection. The name of the mutex is epoxzqjor, as shown in the previous section.

![Figure 36. Mutax creation routine in shellcode](image%2036.png)

Figure 36. Mutax creation routine in shellcode

After creating the mutax, it acquires the file path and traverses all user folders, encrypts them, and drops a ransom note in each folder.

![Figure 37. File encryption and folder-specific Readme.txt drop routine](image%2037.png)

Figure 37. File encryption and folder-specific Readme.txt drop routine

The key used for encryption is then deleted to make it unrecoverable.

## Conclusion

This Magnitude EK exploits web browser vulnerabilities, especially those in older versions of IE, to distribute and execute the DLL malware Magniber via multiple landing pages.

In particular, it utilizes VBScript to perform DLL injection, which is not currently supported by Chrome or Firefox, highlighting the importance of using the latest browsers.

The malicious DLL Magniber effectively evades AV by indirectly calling functions and copying shellcode in the data section to evade various detection methods, and it also stands out for its efforts in terms of compatibility by modifying parts of the shellcode depending on the OS version and build number.

In the end, we would have liked to have been able to analyze the shellcode, which has core functions ranging from file encryption to volume shadow deletion identified by dynamic analysis, but due to the limitations of our knowledge, we were unable to decompile and analyze the shellcode.

However, it is clear that the malicious DLL does not identify any self-destructing or persistence functions after execution, and we observed that it encrypts only files with user-friendly file extensions, leaving files that are essential for system operation intact. This could be easily verified by decompiling the shellcode to see exactly which files are being encrypted and by what algorithm.
